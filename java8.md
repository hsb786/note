### 行为参数化

+ 让方法接受多种行为作为参数，并在内部使用，来完成不同的行为

+ 传递代码，就是将新行为作为参数传递给方法。为接口声明许多只用一次的实体类造成啰嗦代码，在Java8之前可以用匿名类来减少



策略模式：定义一族算法，把它们封装起来（称为 “策略”），然后在运行时选择一个算法

![](D:\note\image\参数化filterApples的行为并传递不同的筛选策略.png)



**匿名类**

运行你同时声明并实例化一个类。允许你随用随建



----

### Lambda

+ 匿名 —— 没有名称
+ 函数 —— Lambda函数不像方法那样属于某个特定的类，但和方法一样，Lambda有参数列表、函数主体、返回类型，还可能有可以抛出的异常列表



#### 函数式接口

> 只定义一个抽象方法的接口

Lambda表达式允许你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例



java.util.function.Predicate<T> 接口定义了一个名叫test的抽象方法，它接受泛型T对象，并返回一个boolean

java.util.function.Consumer<T> 接口定义了一个名叫accept的抽象方法，它接受泛型T对象，没有返回

java.util.function.Function<T , R> 接口定义了一个名叫apply的抽象方法，它接受泛型T对象，并返回一个泛型R对象



Predicate<T>中的T只能绑定到引用类型，装箱后的值本质上就是把原始类型包裹起来，并保存在堆里。因此，装箱后的值需要更多的内存，并需要额外的内存搜索来获取被包裹的原始值

Java8为函数式接口提供了专门的版本，以便在输入和输出都是原始类型时避免自动装箱的操作



#### 方法引用

+ 指向静态方法的方法引用
+ 指向任意类型实例方法的方法引用
+ 指向现有对象的实例方法的方法引用

![](D:\note\image\为三种不同类型的Lambda表达式构建方法引用的办法.png)



~~~
inventory.sort((a1,a2) -> a1.getWeight().compareTo(a2.getWeight()));

import static java.util.Comparator.comparing;
inventory.sort(comparing(a->a.getWeight));

Comparator<Apple> c=Comparator.comparing(Apple::weight)

inventory.sort(comparing(Apple::getWeight));
~~~



----

### Stream

> 从支持数据处理操作的源生成的一系列元素

流的特点

- 声明性 —— 更简洁，更易读
- 可复合 —— 更灵活
- 可并行 —— 性能更好



+ 集合是数据结构，它的主要目的是以特定的时间/空间复杂度存储和访问元素
+ 流以声明性方式处理数据集合，

集合与流之间的差异就在于声明时候进行计算

+ 集合是一个内存中的数据结构，它包含数据结构中目前所有的值——集合中的每个元素都得先算出来才能添加到集合中
+ 流是概念上固定的数据结构，其元素是按需计算的



+ 集合：急切创建的（供应商驱动：先把仓库装满，再开始卖）
+ 流：按需计算（需求驱动，实时制造）



> 谓词：返回boolean的函数



流支持map方法，它会接受一个函数作为参数。这个函数会被应用到每个元素上，并将其映射成一个新的元素（使用映射一词，是因为它和转换类似，但其中的细微差别在于它是“创建一个新版本”，而不是去“修改”）



flatMap：把一个流中的每个值都转换成另一个流，然后把所有的流连接起来成为一个流

![](D:\note\image\使用flatMap找出单词列表中各不相同的字符.png)



filter和map等操作是无状态的，它们并不存储任何状态。reduce等操作要存储状态才能计算出一个值。sorted和distinct等操作也要存储状态，因为它们需要把流中的所有元素缓存起来才能返回一个新的流。这种操作称为有状态操作















