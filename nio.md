#### 操作系统与Java基于流的I/O模型有些不匹配。

操作系统要移动的是大块数据（缓冲区），而JVM的I/O类喜欢操作小块数据——单个字节、几行文本。	结果，操作系统送来整块缓冲区的数据，java.io的流数据类再花大量时间把它们拆成小块，往往拷贝一个小块就要往返于几层对象。	

操作系统喜欢整卡车地运来数据，java.io类则喜欢一铲子一铲子地加工数据。有了NIO，就可以轻松地把一卡车数据备份到你能直接使用的地方(ByteBuffer对象)



#### limit() 上界

上界属性指明了缓冲区有效内容的末端



#### flip() 翻转

~~~
limit=position;
position=0;
mark=-1;
~~~



flip() 函数将一个能够继续添加数据元素的填充状态的缓冲区翻转成一个准备读出元素的释放状态



#### rewind()

rewind()与flip()相似，但不影响上界属性。它只是将位置值设回0.

可以使用rewind()后退，重读已经被翻转的缓冲区中的数据



> 缓冲区并不是线程安全的
>
> clear()函数将缓冲区重置为空状态。它并不改变缓冲区中的任何数据元素，而是仅仅将上界设为容量的值，并把位置设回0



#### compact() 压缩

> 丢弃已经释放的数据，保留未释放的数据，并使缓冲区对重新填充容量准备就绪

![](D:\note\image\压缩前.png)

buffer.compact();

![](D:\note\image\压缩后.png)

数据元素2-5被复制到0-3位置。位置4和5不受影响，但现在正在或已经超出了当前位置，因此是“死的”。



#### mark() 标记

> 使缓冲区能够记住一个位置并在之后将其返回

缓冲区的标记在mark()函数被调用之前是未定义的，调用时标记被设为当前位置的值。reset()函数将位置设为当前的标记值。如果标记值未定义，调用reset()将导致InvalidMarkException异常。一些缓冲区函数会抛弃已经设定的标记（rewind()，clear()，以及flip()总是抛弃标记）。如果新设定的值比当前的标记小，调用limit()或position()带有索引参数的版本会抛弃标记



#### equals()

判断缓冲区中剩余的内容是否相同

两个 缓冲区被认为相等的充要条件是：

+ 两个对象类型相同
+ 两个对象都剩余同样数量的元素。Buffer的容量不需要相同，而且缓冲区中剩余数据的索引也不必相同。但每个缓冲区中剩余元素的数目（从位置到上界）必须相同
+ 在每个缓冲区中应被get()函数返回的剩余数据元素序列保持一致



#### 批量移动

~~~
public CharBuffer get(char[] dst){
	return get(dst,0,dst.length)
}
public CharBuffer get(char[] dst,int offseet,int length)
~~~

有两种形式的get()可供从缓冲区到数组进行的数据复制使用。

批量移动总是具有指定的长度，也就是要求移动固定数量的数据元素

> 批量传输的大小总是固定的。省略长度意味着整个数组会被填满

如果你所要求的数量的数据不能被传送，那么不会有数据被传递，缓冲区的状态保持不变，同时抛出BufferUnderflowException异常。因此当你传入一个数组并且没有指定长度，你就相当于要求整个数组被填充。如果缓冲区中的数据不够完全填满数组，你会得到一个异常。这意味着如果你想将一个小型缓冲区传入一个大型数组，你需要明确地指定缓冲区中剩余的数据长度

~~~
char[] bigArray=new char[1000];
int length=buffer.remaining();
buffer.get(bigArray,0,length);
~~~



----

#### 创建缓冲区

~~~
public static CharBuffer allocate(int capacity);

public static CharBuffer wrap(char[] array);
public static CharBuffer wrap(char[] array,int offset,int length);
~~~



通过静态工厂方法来创建响应类的实例

+ 分配操作创建一个缓冲区对象并分配一个私有的空间来存储容量大小的数据元素
+ 包装操作创建一个缓冲区对象但是不分配任何空间来存储数据元素。它使用你所提供的数组作为存储空间来存储缓冲区中的数据元素

~~~
隐含地从堆空间中分配了一个char型数组作为备份存储器来存储100个char变量
CharBuffer charBuffer=CharBuffer.allocate(100);
~~~



~~~
//创建了一个position值为12,limit值为54，容量为myArray.length的缓冲区
CharBuffer charBuffer=CharBuffer.wrap(myArray,12,42);
~~~



> 通过allocate()或者wrap()函数创建的缓冲区通常都是间接的，间接的缓冲区使用备份数组，可以通过API函数获得对这些数组的存取权。Boolean函数hasArray()告诉你这个缓冲区是否有一个可存取的备份数组。如果这个函数的返回为true，array()函数会返回这个缓冲区对象所使用的数组存储空间的引用。



----



#### 复制缓冲区

> 复制一个缓冲区会创建一个新的Buffer对象，但并不复制数据。原始缓冲区和副本都会操作同样的数据元素

~~~
public abstract CharBuffer duplicate();
~~~



+ duplicate()函数创建了一个与原始缓冲区相似的新缓冲区。
+ 两个缓冲区共享数据元素，拥有同样的容量，但每个缓冲区拥有各自的位置，上界和标记属性。
+ 对一个缓冲区内的数据元素所做的改变会反映的另外一个缓冲区上。
+ 这一副本缓冲区具有与原始缓冲区同样的数据视图。如果原始的缓冲区为只读，或者为直接缓冲区，新的缓冲区将继承这些属性



可以使用asReadOnlyBuffer()函数来生成一个只读的缓冲区视图。这与duplicae()相同，除了这个新的缓冲区不允许使用put()，并且其isReadOnly()函数将会返回true。

~~~
public abstracttt CharBufferr asReadOnlyBuffer();
~~~



分隔缓冲区与复制相似，但slice()创建一个从原始缓冲区的当前位置开始的新缓冲区，并且其容量是原始缓冲区的剩余元素数量（limit-position）。这个新缓冲区与原始缓冲区共享一段数据元素子序列。

----



#### 非直接缓冲区

向一个通道中传递一个非直接ByteBuffer对象用于写入，通道可能会在每次调用中隐含地进行下面的操作

1. 创建一个临时的直接ByteBuffer对象
2. 将非直接缓冲区的内容复制到临时缓冲中
3. 使用临时缓冲区执行低层次I/O操作
4. 临时缓冲区对象离开作用域，并最终成为被回收的无用数据



直接缓冲区是I/O的最佳选择，但可能比创建非直接缓冲区要花费更高的成本。直接缓冲区使用的内存是通过调用本地操作系统方面的代码分配的，绕过了标准JVM堆栈。建立和销毁直接缓冲区会明显比具有堆栈的缓冲区更加破费，这取决于操作系统以及JVM实现。直接缓冲区的内存区域不受无用存储单元收集分配，因为它们位于标准JVM堆栈之外



----



#### 视图缓冲区

视图缓冲区通过已存在的缓冲区对象实例的工厂方法来创建。这种视图对象维护它自己的属性，容量，位置，上界和标记，但是和原来的缓冲区共享数据元素

ByteBuffer类允许创建视图来将byte型缓冲区字节数据映射为其它的原始数据类型。例如，asLongBuffer()函数创建一个将八个字节型数据当成一个long型数据来存取的视图缓冲区，这个缓冲区是基础缓冲区的一个切分，由基础缓冲区的位置和上界决定。新的缓冲区的容量是字节缓冲区中存在的元素数量除以视图类型中组成一个数据类型的字节数



----

#### 通道（Channel）

Channel用于在字节缓冲区和位于通道另一侧的实体（通常是一个文件或套接字）之间有效地传输数据

I/O可以分为广义的两大类别：File I/O和Stream I/O。那么相应地有两种类型的通道，它们是文件（file）通道和套接字（socket）通道













