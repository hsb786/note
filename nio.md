#### 操作系统与Java基于流的I/O模型有些不匹配。

操作系统要移动的是大块数据（缓冲区），而JVM的I/O类喜欢操作小块数据——单个字节、几行文本。	结果，操作系统送来整块缓冲区的数据，java.io的流数据类再花大量时间把它们拆成小块，往往拷贝一个小块就要往返于几层对象。	

操作系统喜欢整卡车地运来数据，java.io类则喜欢一铲子一铲子地加工数据。有了NIO，就可以轻松地把一卡车数据备份到你能直接使用的地方(ByteBuffer对象)



#### limit() 上界

上界属性指明了缓冲区有效内容的末端



#### flip() 翻转

flip() 函数将一个能够继续添加数据元素的填充状态的缓冲区翻转成一个准备读出元素的释放状态



#### rewind()

rewind()与flip()相似，但不影响上界属性。它只是将位置值设回0.

可以使用rewind()后退，重读已经被翻转的缓冲区中的数据



> 缓冲区并不是线程安全的
>
> clear()函数将缓冲区重置为空状态。它并不改变缓冲区中的任何数据元素，而是仅仅将上界设为容量的值，并把位置设回0



#### compact() 压缩

> 丢弃已经释放的数据，保留未释放的数据，并使缓冲区对重新填充容量准备就绪

![](D:\note\image\压缩前.png)

buffer.compact();

![](D:\note\image\压缩后.png)

数据元素2-5被复制到0-3位置。位置4和5不受影响，但现在正在或已经超出了当前位置，因此是“死的”。



#### mark() 标记

> 使缓冲区能够记住一个位置并在之后将其返回

缓冲区的标记在mark()函数被调用之前是未定义的，调用时标记被设为当前位置的值。reset()函数将位置设为当前的标记值。如果标记值未定义，调用reset()将导致InvalidMarkException异常。一些缓冲区函数会抛弃已经设定的标记（rewind()，clear()，以及flip()总是抛弃标记）。如果新设定的值比当前的标记小，调用limit()或position()带有索引参数的版本会抛弃标记



#### equals()

判断缓冲区中剩余的内容是否相同

两个 缓冲区被认为相等的充要条件是：

+ 两个对象类型相同
+ 两个对象都剩余同样数量的元素。Buffer的容量不需要相同，而且缓冲区中剩余数据的索引也不必相同。但每个缓冲区中剩余元素的数目（从位置到上界）必须相同
+ 在每个缓冲区中应被get()函数返回的剩余数据元素序列保持一致



#### 批量移动

~~~
public CharBuffer get(char[] dst){
	return get(dst,0,dst.length)
}
public CharBuffer get(char[] dst,int offseet,int length)
~~~

有两种形式的get()可供从缓冲区到数组进行的数据复制使用。

批量移动总是具有指定的长度，也就是要求移动固定数量的数据元素

> 批量传输的大小总是固定的。省略长度意味着整个数组会被填满

如果你所要求的数量的数据不能被传送，那么不会有数据被传递，缓冲区的状态保持不变，同时抛出BufferUnderflowException异常。因此当你传入一个数组并且没有指定长度，你就相当于要求整个数组被填充。如果缓冲区中的数据不够完全填满数组，你会得到一个异常。这意味着如果你想将一个小型缓冲区传入一个大型数组，你需要明确地指定缓冲区中剩余的数据长度

~~~
char[] bigArray=new char[1000];
int length=buffer.remaining();
buffer.get(bigArray,0,length);
~~~







