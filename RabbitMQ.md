> RabbitMQ是AMQP协议的Erlang的实现



消费者连接到RabbitMQ服务器，并订阅到队列上。当消费者消费一条消息时，只是消费消息的消息体（payload）。在消息路由的过程中，消息的标签会丢弃，存入到队列中的消息只有消息体，消费者也只会消费消息体



每个线程把持一个信道，信道复用了Connection的TCP连接

当每个信道的流量不是很大时，复用单一的Connection可以在产生性能瓶颈的情况下有效地节省TCP连接资源。但是当信道本身的流量很大时，这时候多个信道复用一个Connection就会产生性能瓶颈，进而使整体的流量被限制了。此时就需要开辟多个Connection，将这些信道均摊到这些Connection中



#### 消费模式

Basic.Consume（推模式），Basic.Get（拉模式）

> Basic.Consume将信道（channel）置为接收模式，直到取消队列的订阅为止。在接受期间，RabbitMQ会不断地推送消息给消费者，当然推送消息的个数还是会受到Basic.Qos的限制。如果只想从队列获得单条消息而不是持续订阅，可以使用Basic.Get进行消费。但是不能将Basic.Get放在一个循环里来代替Basic.Consume，这样做回严重影响RabbitMQ的性能



#### 消息的确认与拒绝

autoAck等于true时，RabbitMQ会自动把发送出去的消息置为确认，然后从内存（或者硬盘）中删除，而不管消费者是否真正地消费到了这些消息

autoAck等于false时，如果RabbitMQ一直没有收到消费者的确认信号，并且消费此消息的消费者已经断开连接，则RabbitMQ会安排该消息重新进入队列，等待投递给下一个消费者



mandatory参数告诉服务器至少将该消息路由到一个队列中，否则将消息返回给生产者。

immediate参数告诉服务器，如果该消息关联的队列上有消费者，则立刻投递；如果所有匹配的队列上都没有消费者，则直接将消息返还给身材在，不用将消息存入队列而等待消费者了



#### 死信队列

DLX，全称为Dead-Letter-Exchange。

当消息在一个队列中变成死信（dead message）之后，它能被重新被发送到另一个交换器中，这个交换器就是DLX，绑定DLX的队列就称之为死信队列



消息变成死信一般是由于以下几种情况：

+ 消息被拒绝（Basic.Reject/Basic.Nack），并且设置requeue参数为false
+ 消息过期
+ 队列达到最大长度



#### 延迟队列

延迟队列存储的对象是对应的延迟消息，所谓“延迟消息”是指消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费

+ 在订单系统中，一个用户下单之后通常有30分钟的时间进行支付，如果30分钟之内没有支付成功，那么这个订单将进行异常处理，这时就可以使用延迟队列来处理这些订单了





