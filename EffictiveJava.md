### 创建和销毁对象

#### 考虑使用静态工厂方法代替构造器

**1. 有名称**

当类有多个构造器时，它们的参数列表只在参数类型的顺序上有所不同。面对这样的API，用户永远也记不起该用哪个构造器，结构常常会调用错误的构造器

由于静态方法有名称，所以它们不受上述的限制。当一个类需要构造器时，就用静态工厂方法代替构造器，并且慎重地选择名称以便突出它们之间的区别



**2. 不必在每次调用它们的时候都创建一个新的对象**

这使得不可变类可以使用预先构建好的实例，或者将构建好的实例缓存起来，进行重复利用，从而避免创建不必要的重复对象

静态工厂方法能够为重复的调用返回相同对象，这样有助于类总能严格控制在某个时刻哪些实例应该存在。这种类被称作实例受控的类（instance-controlled）。编写实例受控的类有几个原因。实例受控使得类可以确保它是一个Singleton或者是不可实例化的。它还使得不可变的类可以确保不会存在两个相等的实例。即当且仅当a==b的时候才有a.equals(b)为true。如果类保证了这一点，它的客户端就可以使用==操作符来代替equals(Object)方法


**3. 可以返回原返回类型的任何子类型的对象**

 

----



**原生态类型List和参数化的类型 List<Object> 之间区别**

前者逃避了泛型检查，后者则明确告知编译器  ，它能够持有任意类型的对象。虽然你可以将List<String> 传递给类型List的参数，但是不能将它传给类型List<Object> 的参数。

泛型有子类泛型化（subtyping）的规则，List<String> 是原生态类型List的一个子类型，而不是参数化List<Object> 的子类型  



**原生态类型List和无限制通配符类型List<?>之间区别**

不能将任何原生（除了null之外）放到List<?>中            



`在类文字（class literal）中必须使用原生态类型`。规范不允许使用参数化类型（虽然允许数组类型和基本类型）。换句话说，List.class，String[].class和int.class都合法，但是List<String>.class 和List<?>.class则不合法                                                                                                                                                                                                                                                                                                                             

在参数化类型而非无限制通配符类型上使用instanceof操作符是非法的。用无限制通配符类型代替原生态类型，对instanceof操作 符的行为不会产生任何影响



使用原生态类型会在运行时导致异常，因此不要在新代码中使用。原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。

+ Set<Object>是个参数化类型，表示可以包含任何对象类型的一个集合；
+ Set<?>则是一个通配符类型，表示只能包含某种未知对象类型的一个集合；
+ Set则是个原生态类型，它脱离了泛型系统 