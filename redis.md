eval script numkeys key [key ...] arg [arg ...]

EVAL命令的语义中，脚本里使用的所有键都应该由KEYS数组来传递，因为所有的Redis命令，在执行之前都会被分析，藉此来确定命令会对哪些键进行操作



当redis命令执行结果返回错误时

+ redis.call()：脚本会停止执行，并返回给调用者一个脚本错误
+ redis.pcall()：不引发错误，而是返回一个带err域的Lua表，用于表示错误





当Lua通过call()或pcall()函数执行Redis命令的时候，命令的返回值会被转换成Lua数据结构。同样地，当Lua脚本在Redis内置的解释器理里运行时，Lua脚本的返回值也会被转换成Redis协议，然后由EVAL将值返回给客户端

需要注意的是：

+ Lua boolean true -> Redis integer reply with value of 1		Lua布尔值true转换成Redis整数回复1
+ Lua中整数和浮点数之间没有什么区别。因此，我们始终将Lua的数字转换成整数的回复，这样将舍去小数部分。如果你想从Lua返回一个浮点数，你应该将它作为字符串
+ Lua中nil后面的字符串不会返回



#### 脚本缓存

为了减少 带宽的消耗，Redis实现了EVALSHA命令，它的作用和EVAL一样，都用于对脚本求值，但它接受的第一个参数不是副本，而是脚本的SHA1校验和numkeys

~~~
> set foo bar
OK

> eval "return redis.call('get','foo')" 0
"bar"

// 如果服务器还记得给定的SHA1校验和所指定的脚本，那么执行这个脚本
> evalsha 6b1bf486c81ceb7edf3c093f4c48582e38c0e791 0
"bar"

// 如果服务器不记得的话，那么它返回一个特殊的错误
>evalsha ffffffffffffffffffffffff 0
(error) `NOSCRIPT` No matching script. .......
~~~



客户端库的底层实现可以一直乐观地使用EVALSHA来代替EVAL，并期望着要使用的脚本已经保存在服务器上了，只有当NOSCRIPT错误发生时，才使用EVAL命令重新发送脚本，这样就可以最大限度地节省带宽

这也说明了执行EVAL命令时，使用正确的格式来传递键名参数和附加参数的重要性：因为如果将参数硬写在脚本中，那么每次当参数改变的时候，都要重新发送脚本，即使脚本的主体并没有改变；相反，通过使用正确的格式来传递键名参数和附加参数，就可以在脚本主体不变的情况下，直接使用EVALSHA命令对脚本进行复用，免去了无谓的带宽消耗



Redis保证所有被运行过的脚本都会被永久保存在脚本缓存当中，这意味着，当EVAL命令在一个Redis实例上成功执行某个脚本之后，随后针对这个脚本的所有EVALSHA命令都回成功执行



#### Redis事务

Redis在事务失败时不进行回滚，而是继续执行余下的命令



#### 内部编码

Redis的每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的内部编码

+ 可以改进内部编码，而对外的数据结构和命令没有影响
+ 多种内部编码实现可以在不同场景下发挥各自的优势



#### 单线程架构

> Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务

因为Redis是单线程来处理命令的，所以一条命令从客户端到达服务端不会立刻被执行，所有命令都会进入一个队列中，然后逐个被执行



Redis处理能力快的原因：

+ 纯内存访问
+ IO多路复用。非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间
+ 单线程避免了线程切换和竞态产生的消耗
  + 单线程可以简化数据结构和算法的实现
  + 单线程避免了线程切换和竞态产生的消耗

但是单线程会有一个问题：对于每个命令的执行时间是有要求的。如果某个命令执行过长，会造成其他命令的阻塞，对于Redis这种高性能的服务来说是致命的，所以Redis是面向快速执行场景的数据库



----



#### 常用命令

set key value [ex seconds] \[px milliseconds] \[nx|xx]

+ ex seconds：为键设置秒级过期时间
+ px milliseconds：为键设置毫秒级过期时间
+ nx：键必须不存在，才可以设置成功，用于添加
+ xx：与nx相反，键必须存在，才可以设置成功，用于 更新

~~~
setex key seconds value
setnx key value
~~~



~~~
>set hello world
OK

// 存在键hello，setnx失败
>setnx hello redis
(integer) 0

// 存在键hello，set xx成功
>set hello jedis xx
OK
~~~



blpop和brpop是lpop和rpop的阻塞版本

~~~

~~~



+ key [key ...] 		多个列表的键
+ timeout                    阻塞时间（单位：秒）

列表为空：如果timeout=3，那么客户端要等到3秒后返回，如果timeout=0，那么客户端一直阻塞等下去

+ 如果是多个键，那么brpop会从左至右遍历键，一旦有一个键能弹出元素，客户端立即返回
+ 如果多个客户端对同一个键执行brpop，那么最先执行brpop命令的客户端可以获取到弹出的值



----



#### 数据库管理

Redis默认配置中是有16个数据库

Redis3.0中已经逐渐弱化多数据库了，例如Redis的分布式实现Redis Cluster只允许使用0号数据库，只不过为了向下兼容老版本的数据库功能，该功能没有完全废弃掉

+ Redis是单线程的。如果使用多个数据库，那么这些数据库仍然是使用一个CPU，彼此之间还是会受到影响的
+ 多数据库的使用方式，会让调试和运维不同业务的数据库变的困然，假如有一个慢查询存在，依然会影响其他数据库，这样会使得别的业务方定位问题非常的困然
+ 部分Redis的客户端根本就不支持这种方式。即使支持，在开发的时候来回切换数字形式的数据库，很容易弄乱



+ flushdb清除当前数据库
+ flushall清除所有数据库



----



#### Pipeline（流水线）

Redis客户端执行一条命令分为如下四个过程：

1. 发送命令
2. 命令排队
3. 命令执行
4. 返回结果

其中1和4称为Round Trip Time（RTT，往返时间）



Redis命令真正执行的时间通常在微秒级别，所以才会有Redis性能瓶颈是网络的说法



原生批量命令与Pipeline对比：

+ 原生批量命令是原子的，Pipeline是非原子的
+ 原生批量命令是一个命令对应多个key，Pipeline支持多个命令
+ 原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现



----



#### 发布订阅

+ 客户端在执行订阅命令之后进入了订阅状态，只能接受subscribe、psubscribe、unsubscribe、punsubscribe的四个命令
+ 新开启的订阅客户端，无法收到该频道之前的消息，因为Redis不会对发布的消息进行持久化



----



#### 持久化

Redis支持RDB和AOF两种持久化机制，持久化功能有效地避免因进程退出造成的数据丢失问题，当下次重启时利用之前持久化的文件即可实现数据恢复



#### RDB

RDB持久化是把当前进程数据生成快照保存到硬盘的过程

basave命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束



优点：

+ RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景
+ Redis加载RDB恢复数据远远快于AOF的方式

缺点：

+ RDB方式数据没办法做到实时持久化/秒级持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高
+ RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题



#### AOF

AOF（append only file）持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式

AOF的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load）

+ 所有的写入命令会追加到aof_buf（缓存区）中
+ AOF缓冲区根据对应的策略向硬盘做同步操作
+ 随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的
+ 当Redis服务器重启时，可以加载AOF文件进行数据恢复











