可重复读是MySQL的默认事务隔离级别



**在事务中混合使用存储引擎**

MySQL服务器层不管了事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的

如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM表），在正常提交的情况下不会有什么问题

但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定

在非事务型的表上执行事务相关操作的时候，MySQL通常不会发出提醒，也不会报错。有时候只有回滚的时候才会发出一个警告：“某些非事务型的表上的变更不能被回滚”。但大多数情况下，对非事务型表的操作都不会有提示



**多版本并发控制**

MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提示并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。

可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行

InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较

保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作

MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别和MVCC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁



----



可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节



DATETIME和TIMESTAMP列都可以存储相同类型的数据：时间和日期，精确到秒，然而TIMESTAMP只使用DATETIME一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。另一方面，TIMESTAMP运行的时间范围要小得多，有时候它的特殊能力会成为障碍



**整数类型**

TINYINT  8，SMALLINT  16，MEDIUMINT  24，INT  32，BIGINT  64。

它们存储的值范围从-2^(N-1)到2(N-1)-1，其中N是存储空间的位数

整数类型有可选的UNSIGNED属性，表示不允许负值，这大致可以使正数的上限提高一倍。例如TINYINT UNSIGNED可以存储的范围是0~255，而TINYINT的存储范围是-128~127

MySQL可以为整数类型指定宽度，例如INT(11)，对大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数。对于存储和计算来说，INT(1)和INT(20)是相同的



**实数类型**

实数是带有小数部分的数字。

因为CPU不支持对DECIMAL的直接计算，所以MySQL服务器自身实现了DECIMAL的高精度计算。相对而言，CPU直接支持原生浮点计算，所以浮点运算明显更快



**字符串类型**

VARCHAR类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，因为它仅使用必要的空间

VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于等于255字节，则只使用1个字节表示，否则使用2个字节。例如varchar(10)需要11个字节的存储空间，varchar(1000)需要1002个字节

当存储CHAR值时，MySQL会删除所有的末尾空格，VARCHAR会保留



**BLOB和TEXT类型**

BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储

与其他类型不同，MySQL把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊的处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值

MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length字节而不是整个字符串做排序。

MySQL不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序



**日期和时间类型**

DATETIME：这个类型能保存大范围的值，从1001年到9999年，精度为秒。它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间

默认情况下，MySQL以一种可排序的、无歧义的格式显示DATETIME值，例如"2008-01-01 01:01:22"



TIMESTAMP：该类型保存了从1970年1月1日以来的秒数。TIMESTAMP只使用4个字节的存储空间，因此它的访问比DATETIME小得多：只能表示从1970年到2038年。MySQL提供了FROM_UNIXTIME()函数把UNIX时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数把日期转换为Unix时间戳

TIMESTAMP显示的值依赖于时区；默认情况下，如果插入时没有指定第一个TIMESTAMP列的值，MySQL则设置这个列的值为当前时间。TIMESTAMP列默认为NOT NULL



**MySQL schema 设计中的陷阱**

MySQL的存储引擎API工作时需要在服务层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。MyISAM的变长行结构和InnoDB的行结构则总是需要转换。转换的代价依赖于列的数量。



**范式和反范式**

> 一个人有两块手表就永远不知道时间



范式的优点：

+ 范式化的更新操作通常比反范式化更快
+ 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据
+ 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快
+ 很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句

范式化设计的schema的缺点是通常需要关联。稍微复杂一些的查询语句在符合范式的schema上都可能需要至少一次关联，也许更多。这不但代价昂贵，也可能使一些索引策略无效。例如，范式化可能将列存放在不同的表中，而这些列如果在一个表中本可以属于同一个索引



**缓存表和汇总表**

假设需要计算之前24小时内发送的消息数。在一个很繁忙的网站不可能维护一个实时精确的计算器。作为替代方案，可以每小时生成一张汇总表。这样也许一条简单的查询就可以做到，并且比实时维护计数器要高效得多。缺点是计数器并不是100%精确



为了提升读查询的速度，经常会需要建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法会增加写查询的负担，也需要额外的维护任务，但在设计高性能数据库时，这些都是常见的技巧：虽然写操作变得更慢了，但更显著地提高了读操作的性能

然而，写操作变慢并不是读操作变得更快所付出的唯一代价，还可能同时增加了读操作和写操作的开发难度



**加快ALTER TABLE操作的速度**

MySQL的ALTER TABLE操作的性能对大表来说是个大问题。MySQL执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。这样操作可能需要花费很长时间，如果内存不足而表又很大，而且还有很多索引的情况下尤其如此。有时候ALTER TABLE操作需要花费数个小数甚至数天才能完成



+ alter只能修改默认值，而且alter语句只是修改.frm文件而不涉及表中数据
+ change可以修改字段名、类型、默认值，但是会更新表中数据，操作慢
+ modify可以修改类型、默认值，而且也会更新表中数据，操作慢

change和modify操作将导致表重建



下面这些操作是有可能不需要重建表的：

+ 移除（不是增加）一个列的AUTO_INCREMENT属性
+ 增加、移除、或更改ENUM和SET常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字符串

基本的技术是为想要的表结构创建一个新的.frm文件，然后用它替换掉已经存在的那张表的.frm文件

1. 创建一张有相同结构的空表，并进行所需要的修改（例如增加ENUM变量）
2. 执行FLUSH TABLES WITH READ LOCK。这将会关闭所有正在使用的表，并且禁止任何表被打开
3. 交换.frm文件
4. 执行UNLOCK TABLES 来释放第2步的读锁



尽可能保持任何东西小而简单总是好的：

+ 尽量避免过度设计，例如会导致极其复杂查询的schema设计，或者有很多列的表设计
+ 使用小而简单的合适数据类型，除非真实数据模型中有确切的需要，否则应该尽可能地避免使用NULL值
+ 尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列
+ 注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存
+ 尽量使用整型定义标识列
+ 避免使用MySQL已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度
+ 小心使用ENUM和SET。虽然它们用起来很方便，但是不要滥用，否则有时候会变成陷阱。最好避免使用BIT

----



**索引**

索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。

在MySQL中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样





