可重复读是MySQL的默认事务隔离级别



**在事务中混合使用存储引擎**

MySQL服务器层不管了事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的

如果在事务中混合使用了事务型和非事务型的表（例如InnoDB和MyISAM表），在正常提交的情况下不会有什么问题

但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定

在非事务型的表上执行事务相关操作的时候，MySQL通常不会发出提醒，也不会报错。有时候只有回滚的时候才会发出一个警告：“某些非事务型的表上的变更不能被回滚”。但大多数情况下，对非事务型表的操作都不会有提示



**多版本并发控制**

MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提示并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。

可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了非阻塞的读操作，写操作也只锁定必要的行

InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较

保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作

MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别和MVCC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁



----



可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节



DATETIME和TIMESTAMP列都可以存储相同类型的数据：时间和日期，精确到秒，然而TIMESTAMP只使用DATETIME一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。另一方面，TIMESTAMP运行的时间范围要小得多，有时候它的特殊能力会成为障碍



**整数类型**

TINYINT  8，SMALLINT  16，MEDIUMINT  24，INT  32，BIGINT  64。

它们存储的值范围从-2^(N-1)到2(N-1)-1，其中N是存储空间的位数

整数类型有可选的UNSIGNED属性，表示不允许负值，这大致可以使正数的上限提高一倍。例如TINYINT UNSIGNED可以存储的范围是0~255，而TINYINT的存储范围是-128~127

MySQL可以为整数类型指定宽度，例如INT(11)，对大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数。对于存储和计算来说，INT(1)和INT(20)是相同的



**实数类型**

实数是带有小数部分的数字。

因为CPU不支持对DECIMAL的直接计算，所以MySQL服务器自身实现了DECIMAL的高精度计算。相对而言，CPU直接支持原生浮点计算，所以浮点运算明显更快



**字符串类型**

VARCHAR类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，因为它仅使用必要的空间

VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于等于255字节，则只使用1个字节表示，否则使用2个字节。例如varchar(10)需要11个字节的存储空间，varchar(1000)需要1002个字节

当存储CHAR值时，MySQL会删除所有的末尾空格，VARCHAR会保留



**BLOB和TEXT类型**

BLOB和TEXT都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储

与其他类型不同，MySQL把每个BLOB和TEXT值当作一个独立的对象处理。存储引擎在存储时通常会做特殊的处理。当BLOB和TEXT值太大时，InnoDB会使用专门的“外部”存储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值

MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对每个列的最前max_sort_length字节而不是整个字符串做排序。

MySQL不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序



**日期和时间类型**

DATETIME：这个类型能保存大范围的值，从1001年到9999年，精度为秒。它把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。使用8个字节的存储空间

默认情况下，MySQL以一种可排序的、无歧义的格式显示DATETIME值，例如"2008-01-01 01:01:22"



TIMESTAMP：该类型保存了从1970年1月1日以来的秒数。TIMESTAMP只使用4个字节的存储空间，因此它的访问比DATETIME小得多：只能表示从1970年到2038年。MySQL提供了FROM_UNIXTIME()函数把UNIX时间戳转换为日期，并提供了UNIX_TIMESTAMP()函数把日期转换为Unix时间戳

TIMESTAMP显示的值依赖于时区；默认情况下，如果插入时没有指定第一个TIMESTAMP列的值，MySQL则设置这个列的值为当前时间。TIMESTAMP列默认为NOT NULL



**MySQL schema 设计中的陷阱**

MySQL的存储引擎API工作时需要在服务层和存储引擎层之间通过行缓冲格式拷贝数据，然后再服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。MyISAM的变长行结构和InnoDB的行结构则总是需要转换。转换的代价依赖于列的数量。



**范式和反范式**

> 一个人有两块手表就永远不知道时间



范式的优点：

+ 范式化的更新操作通常比反范式化更快
+ 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据
+ 范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快
+ 很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句

范式化设计的schema的缺点是通常需要关联。稍微复杂一些的查询语句在符合范式的schema上都可能需要至少一次关联，也许更多。这不但代价昂贵，也可能使一些索引策略无效。例如，范式化可能将列存放在不同的表中，而这些列如果在一个表中本可以属于同一个索引



**缓存表和汇总表**

假设需要计算之前24小时内发送的消息数。在一个很繁忙的网站不可能维护一个实时精确的计算器。作为替代方案，可以每小时生成一张汇总表。这样也许一条简单的查询就可以做到，并且比实时维护计数器要高效得多。缺点是计数器并不是100%精确



为了提升读查询的速度，经常会需要建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法会增加写查询的负担，也需要额外的维护任务，但在设计高性能数据库时，这些都是常见的技巧：虽然写操作变得更慢了，但更显著地提高了读操作的性能

然而，写操作变慢并不是读操作变得更快所付出的唯一代价，还可能同时增加了读操作和写操作的开发难度



**加快ALTER TABLE操作的速度**

MySQL的ALTER TABLE操作的性能对大表来说是个大问题。MySQL执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。这样操作可能需要花费很长时间，如果内存不足而表又很大，而且还有很多索引的情况下尤其如此。有时候ALTER TABLE操作需要花费数个小数甚至数天才能完成



+ alter只能修改默认值，而且alter语句只是修改.frm文件而不涉及表中数据
+ change可以修改字段名、类型、默认值，但是会更新表中数据，操作慢
+ modify可以修改类型、默认值，而且也会更新表中数据，操作慢

change和modify操作将导致表重建



下面这些操作是有可能不需要重建表的：

+ 移除（不是增加）一个列的AUTO_INCREMENT属性
+ 增加、移除、或更改ENUM和SET常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字符串

基本的技术是为想要的表结构创建一个新的.frm文件，然后用它替换掉已经存在的那张表的.frm文件

1. 创建一张有相同结构的空表，并进行所需要的修改（例如增加ENUM变量）
2. 执行FLUSH TABLES WITH READ LOCK。这将会关闭所有正在使用的表，并且禁止任何表被打开
3. 交换.frm文件
4. 执行UNLOCK TABLES 来释放第2步的读锁



尽可能保持任何东西小而简单总是好的：

+ 尽量避免过度设计，例如会导致极其复杂查询的schema设计，或者有很多列的表设计
+ 使用小而简单的合适数据类型，除非真实数据模型中有确切的需要，否则应该尽可能地避免使用NULL值
+ 尽量使用相同的数据类型存储相似或相关的值，尤其是要在关联条件中使用的列
+ 注意可变长字符串，其在临时表和排序时可能导致悲观的按最大长度分配内存
+ 尽量使用整型定义标识列
+ 避免使用MySQL已经遗弃的特性，例如指定浮点数的精度，或者整数的显示宽度
+ 小心使用ENUM和SET。虽然它们用起来很方便，但是不要滥用，否则有时候会变成陷阱。最好避免使用BIT

----



**索引**

索引（在MySQL中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。这是索引的基本功能。

在MySQL中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样





key(last_name,first_name,dob)

B-Tree索引的限制

+ 如果不是按照索引的最左列开始查找，则无法使用索引。例如索引无法用于查询last_name或者dob，因为这两个查询都不是以last_name开始
+ 不能跳过索引中的列。例如索引无法用于查询last_name，dob
+ 如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询WHERE last_name='Smith' AND first_name LIKE 'J%' AND dob='1976-12-23'，这个查询只能使用索引的前两列



**索引的优点**

最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些查询只使用索引就能够完成全部查询。据此特性，总结下来索引有如下三个优点：

1. 索引大大减少了服务器需要扫描的数据量
2. 索引可以帮助服务器避免排序和临时表
3. 索引可以将随机I/O变为顺序I/O



索引并不总是最好的工具。总的来说，只有当索引帮助存储引擎快速查找到记录带来的好处大于其带来的额外工作时，索引才是有效的。对于非常小的表，大部分情况下简单的全表扫描更高效。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价将随之增长。这种情况下，则需要一种技术可以直接区分查询需要的一组数据，而不是一条记录一条记录地匹配



索引将相关的记录放到一起则获得一星；如果索引中的数据顺序和查找中的排列顺序一致则获得二星；如果索引中的列包含了查询中需要的全部列则获得三星



**高性能的索引策略**

独立的列：索引列不能是表达式的一部分，也不能是函数的参数

~~~
SELECT actor_id FROM sakila.actor WHERE acotr_id+1=5 
~~~



前缀索引和索引选择性

有时候需要索引很长的字符列，这会让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。索引的选择性是指，不重复的索引值（也称为基数，cardinality）和数据表的记录总数（#T）的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的

一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于BLOB、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度

> 前缀的基数应该接近于完整列的基数



计算合适的前缀长度的一个办法是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性

~~~
SELECT COUNT(DIStINCT city)/COUNT(*) FROM city_demo
~~~



~~~
SELECT COUNT(DISTINCT LEFT(city,3))/COUNT(*)   0.0
		 COUNT(DISTINCT LEFT(city,3))/COUNT(*)   0.0
SELECT COUNT(DISTINCT LEFT(city,3))/COUNT(*)   0.0
SELECT COUNT(DISTINCT LEFT(city,3))/COUNT(*)   0.0
SELECT COUNT(DISTINCT LEFT(city,3))/COUNT(*)   0.0
~~~



创建前缀索引

~~~
ALTER TABLE city_demo ADD KEY(city(7))
~~~



前缀索引是一种能使索引更小、更快的有效办法，但另一方面也有其缺点：MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描



多列索引

~~~
CREATE TABLE t(
	c1 INT，
	c2 INT，
	c3 INT，
	KEY(c1)，
	KEY(c2),
	KEY(c3)
)
~~~



这样一来最好的情况下也只能是“一星”索引，其性能比其真正最优的索引可能差几个数量级。有时如果无法设计一个“三星”索引，那么不如忽略掉WHERE子句，集中精力优化索引列的顺序，或者创建一个全覆盖索引

在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0和更新版本引入了一种叫“索引合并”的策略，一定程度上可以使用表上的多个单列索引入了一种叫“索引合并”的策略，一定程度上可以使用表上的多个单列索引来定位指定的行





扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时





尽可能将需要做范围查询的列表放到索引的后面，以便优化器能使用尽可能多的索引列

可以在索引中加入更多的列，并通过IN()的方式覆盖那些不在WHERE子句中的列。但这种技巧也不能滥用，否则可能会带来麻烦。因为每额外增加一个IN()条件，优化器需要做的组合都将以指数形式增加，最终可能会极大地降低查询性能。

~~~
WHERE eye_color 	IN('brown','blule','hazel')
	AND hair_color  IN('black','red','blonde','brown')
	AND sex 	    IN('M','F')
~~~

优化器则会转化成24种组合，执行计划需要检查WHERE子句中所有的24种组合                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     



在选择索引和编写利用这些索引的查询时，有如下三个原则始终需要记住：

1. 单行访问是很慢的。如果服务器从存储中读取一个数据块只是为了获取，那么就浪费了很多工作
2. 按顺序访问范围数据是很快的，这有两个原因。第一，顺序I/O不需要多次磁盘寻道，所以比随机I/O要快得多。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算了
3. 索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不需要再回表查找行。这避免了大量的单行访问

