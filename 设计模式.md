> 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起



> 利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为。然而，如果能够利用组合的做法扩展对象的行为，就可以在运行时动态地进行扩展



>依赖倒置：要依赖抽象，不要依赖具体类

倒置指的是和一般OO设计的思考方式完全相反。从客户端依赖具体的产品类到客户端依赖产品抽象，具体产品类依赖产品抽象；底层依赖高层                                                                                                                                                  

+ 变量不可以持有具体类的引用（如果使用new，就会持有具体类的引用。可以改用工厂来避开这样的做法）
+ 不要让类派生自具体类（如果派生自具体类，你就会依赖具体类。请派生自一个抽象）
+ 不要覆盖基类中已实现的方法（如果覆盖基类已实现的方法，那么你的基类就不是一个真正适合被继承的抽象。基类中已实现的方法，应该由所有的子类共享）







#### 策略模式

定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户





#### 观察者模式

定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新

主题是真正拥有数据的人，观察者是主题的依赖者，在数据变化时更新，这样比起让许多对象控制同一份数据来，可以得到更干净的OO设计

当两个对象之间松耦合，它们依然可以交互，但是不太清除彼此的细节

观察者模式提供了一种设计模式，让主题和观察者之间松耦合；改变主题和观察者其中一方，并不会影响另一方。因为两种时松耦合的，所以只要他们之间的接口仍被遵守，我们就可以自由地改变他们



#### 装饰者模式

动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案



#### 工厂方法

定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类

简单工厂把全部的事情，在一个地方都处理完了，然而工厂方法却是创建一个框架，让子类决定要如何实现



#### 抽象工厂

提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类



+ 工厂方法：从需要实例化的具体类中解耦
+ 抽象工厂：创建产品家族和想让制造的相关产品集合起来



#### 单例模式

确保一个类只有一个实例，并提供一个全局访问点

如果有两个以上的类加载器，不同的类加载器可能会加载同一个类，从整个程序来看，同一个类会被加载多次。所以，如果你的程序有多个类加载器又同时使用了单例模式：请自行指定类加载器，并指定同一个类加载器

+ 同步getInstance()方法：同步会降低性能，如果getInstance()使用在频繁运行的地方，就要重新考虑了
+ 静态初始化：JVM在加载这个类时马上创建此唯一的单例，
+ 双重检查加锁：如果性能是你关系的重点，那么这种方法可以大大减少时间耗费



#### 命令模式

将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作

行为参数化

命令模式将发出请求的对象和执行请求的对象解耦，两种之间通过命令对象进行沟通，命令对象封装了接收者和一个或一组动作



#### 适配器模式

将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间

+ 类适配器：继承被适配者和目标类，java不能使用多继承，所以在java中不能实现
+ 对象适配器：适配器实现目标接口，适配器与被适配者组合



#### 外观模式

提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用

+ 装饰者：不改变接口，但加入责任
+ 适配者：将一个接口转成另一个接口
+ 外观：简化一群接口



#### 模板方法

在一个方法中定义一个算法的框架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤

钩子是一种被声明在抽象类中的方法，但只有空的或者默认的实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。

当你的子类必须提供算法中某个方法或步骤的实现 时，就使用抽象方法。如果算法的这个部分是可选的，就用钩子。



> 好莱坞原则：别调用我们，我们会调用你

在好莱坞原则之下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎么使用这些低层组件。换句话说，高层组件对待低层组件的方式是“别调用我们，我们会调用你”



**好莱坞原则和依赖倒置原则之间的关系**

依赖倒置原则教我们尽量避免使用具体类，而多使用抽象。而好莱坞原则是用在创建框架或组件上的一种技巧，好让低层组件能够被挂钩进计算中，而且又不会让高层组件依赖低层组件。两者的目标都是在于解耦，但是依赖倒置原则是更加注重如何在设计中避免依赖。

好莱坞原则教我们一个技巧，创建一个有弹性的设计，允许低层结构能够互相操作，而又防止其他类太过依赖它们



#### 迭代器模式

提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示

把游走的任务放在迭代器上，而不是聚合上。这样简化了聚合的接口和实现，也让责任各得其所



> 单一责任：一个类应该只有一个引起变化的原因



#### 组合模式

允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合



#### 状态模式

允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类



**状态模式和策略模式**

以状态模式为言，我们将一群行为封装在状态对象中，context的行为随时可委托到那些状态对象中的一个。随着时间的流逝，当前状态在状态对象集合中游走改变，以反映出context内部的状态，因此，context的行为也会跟着改变。但是context的客户对于状态对象了解不多，甚至根本是浑然不觉

而已策略模式而言，客户通常主动指定Context所要组合的策略对象是哪一个。现在，固然策略模式让我们具有弹性，能够在运行时改变策略，但对于某个context对象来说，通常都只有一个最恰当的策略对象

一般来说，我们把策略模式想成是除了继承之外的一种弹性替代方案。如果你使用继承定义了一个类的行为，你将被这个行为困住，甚至要修改它都很难。有了策略模式，你可以通过组合不同的对象来改变行为

我们把状态模式想成是不用在context中放置许多条件判断的替代方案。通过将行为包装进状态对象中，你可以通过context内简单地改变状态对象来改变context行为



#### 代理模式

为另一个对象提供一个替身或占位符以控制对这个对象的访问

使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象，创建开销大的对象或需要安全控制的对象

**RMI**

RMI提供了客户端辅助对象和服务辅助对象，为客户辅助对象创建和服务对象相同的方法。RMI的好处在于你不必亲自写任何网络或I/O代码。客户程序调用远程方法就和运行在客户自己的本地JVM上对对象进行正常方法调用一样

RMI将客户辅助对象称为stub（桩），服务辅助对象称为skeleton（骨架）；rmic是JDK内的一个工具，用来为一个服务类产生stub和skeleton

远程对象就是一种活在不同的Java虚拟机（JVM）堆中的对象

客户如何取得stub对象：

1. 客户到RMI registry中寻找
2. RMI registry返回Stub对象
3. 客户调用stub方法，就想stub就是真正的服务对象一样



动态代理之所以被称为动态，是因为运行时才将它的类创建出来。

InvocationHandler只是一个帮助proxy的类，proxy会把调用转发给它处理。Proxy本身是利用静态的Proxy.newProxyInstance()方法在运行时动态地创建



#### 桥接模式

不只改变你的实现，也改变你的抽象

桥接模式通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变



#### 生成器模式

封装一个产品的构造过程，并允许按步骤构造

 