**类关系**

+ 【继承】extends (is-a)
+ 【实现】implements (can-do)
+ 【组合】类是成员变量 (contains-a)
+ 【聚合】类是成员变量 (has-a)
+ 【依赖】import类 （use-a）

类关系的组合是一种完全绑定的关系，所有成员共同完成一件使命，它们的生命周期是一样的。组合体现的是非常强的整体与部分的关系，同生共死，部分不能在整体之间共享。实心

聚合是一种可以拆分的整体与部分的关系，是非常松散的暂时组合，部分可以被拆出来给另一个整体

依赖是除组合和聚合外的类与类之间的关系，这个类只要import，那就是依赖关系



**序列化**

java原生序列化

Java类通过实现Serializable接口来实现该类对象的序列化，实现Serializable接口的类建议设置serialVersionUID字段值，如果不设置，那么每次运行时，编译器会根据类的内部实现，包括类名、接口名、方法和属性等来自动生成serialVersionUID。如果类的源代码有修改，那么重新编译后serialVersionUID的取值可能会发生变化。因此实现Serializable接口的类一定要显式地定义serialVersionUID属性值。修改类时需要根据兼容性决定是否修改serialVersionUID值

+ 如果是兼容升级，请不要修改serialVersionUID字段，避免反序列化失败
+ 如果是不兼容升级，需要修改serialVersionUID值，避免反序列化混乱

使用Java原生序列化需注意，Java反序列化时不会调用类的无参构造方法，而是调用native方法将成员变量赋值为对应类型的初始值



Json序列化

JSON是一种轻量级的数据交换格式。JSON序列化就是将数据对象转换为JSON字符串。在序列化的过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确地反序列化

----

Java中的参数传递都是值复制的传递过程。对于引用变量，复制指向对象的首地址，双方都可以通过自己的引用变量修改指向对象的相关属性



在接口中不能定义构造方法，在抽象类中可以定义。在枚举类中，构造方法是特殊的存在，它可以定义，但不能加public修饰，因为它默认是private的，是绝对的单例，不允许外部以创建对象的方式生成枚举对象



单一职责，对于构造方法同样适用，构造方法的使命就是在构造对象时进行传参操作，所以不应该在构造方法中引入业务逻辑。如果在一个对象生产中，需要完成初始化上下游对象、分配内存、执行静态方法、赋值句柄等繁重的工作，其中某个步骤出错，导致没有完成对象初始化，再将希望寄托于业务逻辑部分来 处理异常就是一件不受控制的事情了。故推荐将初始化业务逻辑放在某个方法中，比如init()，当对象确认完成所有初始化工作之后，再显式调用



易出错的getter与setter方法定义方式：

+ getter/setter中添加业务逻辑。问题出现时，程序员的惯性思维会忽略getter/setter方法的嫌疑，这会增加排查问题的难度
+ 同时定义isXxx()和getXxx()。在类定义中，两者同时存在会在iBATIS、JSON序列化等场景下引起冲突、比如，iBATIS通过反射机制解析加载属性的getter方法时，首先会获取对象所有的方法，然后筛选出以get和is开头的方法，并存储到类型为HashMap的getMethods变量中。其中key为属性名称，value为getter方法。因为isXxx()和getXxx()方法只能保留一个，哪个方法被后存储到getMethods变量中，就会保留哪个方法，具有一定的随机性。所以当两者定义不同时，会导致误用，进而产生问题



想成功地覆写父类方法，需要满足以下4个条件：

+ 访问权限不能变小。 意味着在调用时父类的可见方法无法被子类多态执行。设想如果编译器为多态开了后门，让在父类定义中可见的方法随着父类调用链路下来，执行了子类更小权限的方法，则破坏了封装
+ 返回类型能够向上转型类父类的返回类型。这里的向上转型必须时严格的继承关系，数据类型基本不存在通过继承向上转型的问题
+ 异常也要能向上转型称为父类的异常
+ 方法名、参数类型及个数必须严格一致



JVM在重载方法中，选择合适的目标方法的顺序如下：

1. 精确匹配
2. 如果是基本数据类型，自动转换成更大表示范围的基本类型
3. 通过自动拆箱与装箱
4. 通过子类向上转型继承匹配路线以此匹配
5. 通过可变参数匹配

注意，null可以匹配任何类对象，在查找目标方法时，是从最底层子类依次向上查找的。如果存在methodForOverload(Integer)，调用methodForOverload(null)，则会调用参数为Integer的方法。第一，因为Integer是一个类；第二，它是Object的子类。如果还有单个String类型参数的方法，则会编译出错，因为null不知道该选择Integer，还是String 

----



**泛型**

泛型可以定义在类、接口、方法中，编译器通过识别尖括号和尖括号内的字母来解析泛型。在泛型定义时，约定俗成的符号包括：E代表Element，用于集合中的元素；T代表the Type of object，表示某个类；K代表Key、V代表Value，用于键值对元素

+ 尖括号里的每个元素都指代一种未知类型
+ 尖括号的位置非常讲究，必须在类名之后或方法返回值之前
+ 泛型在定义处中具备执行Object方法的能力
+ 对于编译之后的字节码指令，其实没有这些花头花脑的方法签名，充分说明了泛型只是一种编写代码时的语法检查



泛型就是在编译期增加了一道检查而已，目的是促使程序员在使用泛型时安全放置和使用数据。使用泛型的好处包括：

+ 类型安全。放置的是什么，取出来的自然是什么，不用担心会抛出ClassCastExcepiton异常
+ 提示可读性。从编码阶段就显式地知道泛型集合、泛型方法等处理的对象类型是什么
+ 代码重用。泛型合并了同类型的处理代码，使代码重用度变高



> 事情有变坏的可能，不管这种可能性有多小，它总会发生  —— 墨菲定律

----



作为一个引用变量，refvar均占用4B空间。无论refobj是多么小的对象，最小占用的存储空间是12B（用于存储基本信息，称为对象头），但由于存储空间分配必须是8B的倍数，所以初始分配的空间至少是16B

基本数据类型int占用4个字节，而对应的包装类Integer实例对象占用16个字节。这是因为字段属性除成员属性int value外，其他的如MAX_VALUE等都是静态成员变量，在类加载时就分配了内存，与实例对象容量无关。此外，类定义中的方法代码不占用实例对象的任何空间。IntegerCache是Integer的静态内部类，容量占用也与实例对象无关。由于refobj对象的基础大小是12B，再加上int是4B，所以Integer实例对象占用16B



在选择使用包装类还是基本数据类型时，推荐使用如下方式：

1. 所有的POJO类属性必须使用包装数据格式
2. RPC方法的放回值和参数必须使用包装数据类型
3. 所有的局部变量推荐使用基本数据类型



卫语句就是把复杂的条件表达式拆分成多个条件表达式，比如一个很复杂的表达式，嵌套了好几层的if - then-else语句，转换为多个if语句，实现它的逻辑，这多条的if语句就是卫语句



----



> 计算机工程领域的任何问题都可以通过增加一个中间层来解决



防御式编程、契约式编程

服务方方法的返回值可以为null，不强制返回空集合或者空对象等，但是必须添加注释充分说明说明情况下会返回null值。防止NPE一定是调用方的责任，需要调用方进行事先判断 



**日志级别**

+ DEBUG：记录对调试程序有帮助的信息
+ INFO：用来记录程序运行现场，虽然此处并没未发生错误，但是对排查其他错误具有指导意义
+ WARN：也可以用来记录程序运行现场，但是更偏向于表面此处有出现潜在错误的可能
+ ERROR：表明当前程序运行发生了错误，需要被关注。但是当前发生的错误，没有影响系统的继续运行
+ FATAL：表明当前程序运行出现了严重的错误事件，并且将会导致应用程序中断

ERROR级别只记录系统逻辑错误、异常或者违反重要的业务规则；一些可以通过引导重试就能恢复正常的用WARN



**预先判断日志级别**

对DEBUG、INFO级别的日志，必须使用条件输出或者使用占位符的方式打印。该约定综合考虑了程序的运行效率和日志打印需求。例如，在某个配置了打印日志级别为WARN的应用中，如果针对DEBUG级别的日志，仅仅在程序中写出logger.debug("xxx")；那么该日志不会被打印，但是会执行字符串拼接操作

~~~
// 使用条件判断形式
if(logger.isDebugEnabled()){
    logger.debug("xxx");
}
// 使用占位符形式
logger.debug("Processing trade with id:{} and symbol:{}",id,symbol);
~~~



----



```
List<String> list = new ArrayList<>(Arrays.asList("One", "Two", "Three"));
// 泛型丢失
Object[] array1 = list.toArray();

// 接收方数组容量不够，弃用
String[] array2 = new String[2];
list.toArray(array2);
System.out.println(Arrays.asList(array2));

// 接收方数组容量足够，复制，剩余的未null
String[] array4 = new String[4];
list.toArray(array4);
System.out.println(Arrays.asList(array4));
```



List<?> 问号在正则表达式中可以匹配任何字符，List<? > 称为通配符集合。它可以接收任何类型的集合引用赋值，不能添加任何元素，但可以remove和clear，并非immutable集合。List<? >一般作为参数来接收外部的集合，或者返回一个不知道具体元素类型的集合



<? extends T> 可以赋值给任何T及T子类的集合，上界为T，取出来类型带有泛型限制，向上强转型为T。null可以表示任何类型，所以除null外，任何元素都不得添加<? extends T>集合内

<? super T> 可以赋值给任何T及T的父类集合，下界为T。取出来类型丢失，可以添加T和T的子类对象

extends GetFirst			super  PutFirst

----



**fail-fast**

对集合遍历操作时的错误检测机制，在遍历中途出现意料之外的修改时，通过unchecked异常暴力地反馈出来。

这种机制经常出现在多线程环境下，当前线程会维护一个计数比较器，即expectedModCount，记录已经修改的次数。在进入遍历前，会把实时修改次数modCound赋值给expectedModCount，如果这两个数据不相等，则抛出异常。java.util下的所有集合类都是fail-fast



**fail-safe**

concurrent包中的集合类都是fail-safe

Copy-On-Write，它是并发的一种新思路，实行读写分离，如果是写操作，则复制一个新集合，在新集合内添加或删除元素。待一切修改完成之后，再将原集合的引用指向新的集合。适用于读多写极少的场景

COW是fail-safe机制的，在并发包的集合中都是由这种机制实现的，fail-safe是在安全的副本（或者没有修改操作的正本）上进行遍历，集合修改与副本的遍历是没有任何关系的，但是缺点也很明显，就是读取不到最新的数据。这也是CAP理论中C(Consistency)与A(Availability)的矛盾，即一致性与可用性的矛盾



----



HashMap是使用hashCode和equals实现去重的。而TreeMap依靠Comparable或Comparator来实现Key的去重

TreeMap 线程不安全，key不能为null



同步代码块中使用monitorenter及monitorexit两个字节码指令获取和是否monitor。如果使用monitorenter进入时monitor为0，表示该线程可以持有monitor后续代码，并将monitor为1；如果当前线程已经持有了monitor，那么monitor继续加1；如果monitor非0，其他线程就会进入阻塞状态。





ThreadLocal：统一设置初始值，但是每个线程对这个值的修改都是互相独立的

局部变量在方法内各个代码块间进行传递，而类内变量在类内方法间进行传递。复杂的线程方法可能需要调用很多方法来实现某个功能，这时候用什么来传递线程内变量？答案就是ThreadLocal，它通常用于同一个线程内，跨类、跨方法传递数据。如果没有ThreadLocal，那么相互之间的信息传递，势必要靠返回值和参数，这样无形之中，有些类甚至有些框架会相互耦合。



ThreadLocal的主要问题是会产生脏数据和内存泄漏。这两个问题通常是在线程池的线程中使用ThreadLocal引发的，因为线程池有线程复用和内存常驻两个特点

脏数据：线程复用会产生脏数据。由于线程池会重用Thread对象，那么与Thread绑定的类的静态属性ThreadLocal变量也会被重用。如果在实现的线程run()方法体中不显式地调用remove()清理与线程相关的ThreadLocal信息，那么倘若下一个线程不调用set()设置初始值，就可能get()到重用的线程信息，包括ThreadLocal所关联的线程对象的value值

