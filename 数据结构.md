栈      分隔符匹配

队列        为了避免队列不满却不能插入新的数据，我们可以让队尾指针绕回到数组开始的位置，这也称为“循环队列”

## 堆
+ 完全二叉树，除了树的最后一层节点不需要是满的，其它的每一层从左到右都是满的。如果最后一层从左到右有间隔，那么也是不完全二叉树
+ 通常用数组来实现，假设节点的索引值为index，那么：
	+ 节点的父节点是(index-1)/2
	+ 节点的左子节点是2*index+1
	+ 节点的右子节点是2*index+2
+ 堆中的每一个节点的关键字都大于（或等于）这个节点的子节点的关键字

堆只有沿着从根节点到叶子节点的每一条路径是降序排列的，相对于二叉查找树来说，堆是弱需的

堆似乎非常接近无序，能够快速的移除最大（或最小）节点，也就是根节点，以及能快速插入新的节点

### 移除根
+ 移走根
+ 把最后一个节点移动到根的位置
+ 向下筛选，遇到大的就交换

### 插入
+ 初始时插入到数组最后第一个空着的单元
+ 向上筛选

## 树
### BST
二叉查找树（Binary Search Tree，简称BST）是一棵二叉树，它的左子节点的值比父节点的值要小，右节点的值要比父节点的值大。它的高度决定了它的查找效率。

二叉搜索树要求：若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树

在理想的情况下，二叉查找树增删查改的时间复杂度为O(logN)（其中N为节点数），最坏的情况下为O(N)。当它的高度为logN+1时，我们就说二叉查找树是平衡的。

### 遍历方式
+ 中序遍历:左子树——》根节点——》右子树   (从小到大排序)
+ 前序遍历:根节点——》左子树——》右子树
+ 后序遍历:左子树——》右子树——》根节点

### BST的删除操作
1. 该节点是叶子节点
2. 该节点有一个子节点
3. 该节点有两个子节点

**case1**
只需将该节点的父节点对该节点的引用设为null即可

**case2**
将其父节点原本指向该节点的引用，改为指向该节点的子节点即可

**case3**
用后继节点代替删除的节点
~~~
//返回后继节点
public Node getSuccessor(Node delNode){
    Node successorParent = delNode;
    Node successor = delNode;
    Node current = delNode.rightChild;
    while(current != null){
        successorParent = successor;
        successor = current;
        current = current.leftChild;
    }
    if(successor != delNode.rightChild){
		//后继节点是删除节点的右子节点的左子节点时
		//用后继节点的左子节点替换后继节点
        successorParent.leftChild = successor.rightChild;
		//后继节点连接删除节点的右子节点
        successor.rightChild = delNode.rightChild;
    }
    return successor;
}

//用后继节点替换删除的节点
Node successor = getSuccessor(current);
if(current == root){
	successor = root;
}else if(isLeftChild){
	parent.leftChild = successor;
}else{
	parent.rightChild = successor;
}
successor.leftChild = current.leftChild;
~~~

### BST存在的问题
BST存在的主要问题是，数在插入的时候会导致树倾斜，不同的插入顺序会导致树的高度不一样，而树的高度直接的影响了树的查找效率。理想的高度是logN，最坏的情况是所有的节点都在一条斜线上，这样的树的高度为N。

### RBTree
基于BST存在的问题，一种新的树——平衡二叉查找树(Balanced BST)产生了。平衡树在插入和删除的时候，会通过旋转操作将高度保持在logN。其中两款具有代表性的平衡树分别为AVL树和红黑树。AVL树由于实现比较复杂，而且插入和删除性能差，在实际环境下的应用不如红黑树。

红黑树（Red-Black Tree，以下简称RBTree）的实际应用非常广泛，比如Linux内核中的完全公平调度器、高精度计时器、ext3文件系统等等，各种语言的函数库如Java的TreeMap和TreeSet，C++ STL的map、multimap、multiset等。

#### 定义
1. 任何一个节点都有颜色，黑色或者红色
2. 根节点是黑色的
3. 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）
4. 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

在红-黑树中插入的节点都是红色的，这不是偶然的，因为插入一个红色节点比插入一个黑色节点违背红-黑规则的可能性更小。原因是：插入黑色节点总会改变黑色高度（违背规则4），但是插入红色节点只有一半的机会会违背规则3。另外违背规则3比违背规则4要更容易修正。

#### 平衡性的修正
插入修复操作分为以下三种情况，而且新插入的节点的父节点都是红色的:
+ 叔叔节点为红色
+ 叔叔节点为空，且祖父节点、父节点和新节点处于一条斜线上
+ 叔叔节点为空，且祖父节点、父节点和新节点不处于一条斜线上

**case1**
将父节点和叔叔节点与祖父节点的颜色互换

**case2**
红色节点向左偏移就右旋，向右偏移就左旋

**case3**
先将插入的节点旋转变为case2，然后对case2进行处理

#### 左旋的具体实现
~~~
/*************对红黑树节点x进行左旋操作 ******************/
/*
 * 左旋示意图：对节点x进行左旋
 *     p                       p
 *    /                       /
 *   x                       y
 *  / \                     / \
 * lx  y      ----->       x  ry
 *    / \                 / \
 *   ly ry               lx ly
 * 左旋做了三件事：
 * 1. 将y的左子节点赋给x的右子节点,并将x赋给y左子节点的父节点(y左子节点非空时)
 * 2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)
 * 3. 将y的左子节点设为x，将x的父节点设为y
 */
private void leftRotate(RBNode<T> x) {
	//1. 将y的左子节点赋给x的右子节点，并将x赋给y左子节点的父节点(y左子节点非空时)
	RBNode<T> y = x.right;
	x.right = y.left;
	
	if(y.left != null) 
		y.left.parent = x;
	
	//2. 将x的父节点p(非空时)赋给y的父节点，同时更新p的子节点为y(左或右)
	y.parent = x.parent;
	
	if(x.parent == null) {
		this.root = y; //如果x的父节点为空，则将y设为父节点
	} else {
		if(x == x.parent.left) //如果x是左子节点
			x.parent.left = y; //则也将y设为左子节点
		else
			x.parent.right = y;//否则将y设为右子节点
	}
	
	//3. 将y的左子节点设为x，将x的父节点设为y
	y.left = x;
	x.parent = y;		
}
~~~

插入后的修复操作是一个向root节点回溯的操作，一旦牵涉的节点都符合了红黑树的定义，修复操作结束。

#### RBTree的删除操作
删除操作首先需要做的也是BST的删除操作，删除操作会删除对应的节点，如果是叶子节点就直接删除，如果是非叶子节点，会用对应的中序遍历的后继节点来顶替要删除节点的位置。删除后就需要做删除修复操作，使树符合红黑树的定义，符合定义的 红黑树高度是平衡的。

删除修复操作是针对删除黑色节点才有的，当黑色节点被删除后会让整个树不符合RBTree的定义的第四条。需要做的处理是从兄弟节点借调黑色节点过来，如果兄弟节点没有黑节点可以借调的话，就只能往上追溯，将每一级的黑节点树减去一个，使得整棵树符合红黑树的定义

**删除修复操作（删除黑色节点后）**
1. 待删除的节点的兄弟节点是红色的节点。
2. 待删除的节点的兄弟节点是黑色的节点，且兄弟节点的子节点都是黑色的。
3. 待调整的节点的兄弟节点是黑色的节点，且兄弟节点的左子节点是红色的，右节点是黑色的(兄弟节点在右边)，如果兄弟节点在左边的话，就是兄弟节点的右子节点是红色的，左节点是黑色的。
4. 待调整的节点的兄弟节点是黑色的节点，且右子节点是是红色的(兄弟节点在右边)，如果兄弟节点在左边，则就是对应的就是左节点是红色的

**case1**
旋转树将兄弟节点提升到父节点

**case2**
将兄弟节点变红

**case3**
将兄弟节点变为case4情况

**case4**
旋转树将兄弟节点提升到父节点

#### 总结
进行红黑树的插入和删除操作的时候，需要向兄弟节点、父节点、侄子节点借调和互换颜色，要达到这个目的，就需要不断的进行旋转。所以红黑树的插入删除操作需要不停的旋转，一旦借调了别的节点，删除和插入的节点就会达到局部的平衡，但是被借调的节点就不会平衡了，这时就需要以被借调的节点为起点继续进行调整，直到整棵树都是平衡的。

整个红黑树的查找，插入和删除都是O(logN)的，原因就是整个红黑树的高度是logN。

### B树 Balance Tree
B树是一种查找树,它最初启发于二叉查找树，二叉查找树的特点是每个非叶节点都只有两个孩子节点。然而这种做法会导致当数据量非常大时，二叉查找树的深度过深，搜索算法自根节点向下搜索时，需要访问的节点也就变的相当多。
B/B+ 树就是N叉(N-ary)平衡树了,每个节点可以有更多的孩子,新的值可以插在已有的节点里,而不需要改变树的高度,从而大量减少重新平衡和数据迁移的次数,这非常适合做数据库索引这种需要持久化在磁盘,同时需要大量查询和插入操作的应用
m阶B树满足以下条件：
+ 每个节点至多拥有m棵子树
+ 根节点至少有两个子节点（除非B树只包含一个节点）
+ 除根节点外，其它节点至少有Ceil(m/2)棵子树(Ceil表示向上取整)
+ 所有叶子节点在同一层
+ 关键字的个数n必须满足：[ceil(m/2)-1] <= n <= m-1，并且以升序排列

### 在B树中插入关键码key的思路
对高度为h的m阶B树，新节点一般是插在第h层。通过检索可以确定关键码应插入的节点位置。然后分两种情况讨论：
+ 若该节点中关键码个数小于m-1，直接插入即可。
+ 若该节点钟关键码个数等于m-1，则将引起节点的分裂。以中间关键码为界将节点一分为二，产生一个新节点，并把中间关键码插入到父节点(h-1层)中.
重复上述工作，最坏情况一直分裂到根节点，建立一个新的根节点，整个B树增加一层。

一棵含有N个总关键字数的m阶的B树的最大高度是多少? log_ceil（m/2）(N+1)/2 + 1 

### B+ 树
B+树是B树的变种树，有n棵子树的节点中含有n个关键字，每个关键字不保存数据，只用来索引，数据都保存在叶子节点。是为文件系统而生的。
树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。